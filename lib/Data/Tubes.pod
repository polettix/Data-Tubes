=pod

=for vim
   vim: tw=72 et ai :

=encoding utf8

=head1 NAME

Data::Tubes - Text and data canalising

=head1 VERSION

This document describes Data::Tubes version 0.01.

=head1 SYNOPSIS

    use Data::Tubes qw< drain summon >;

    # Load components from relevant plugins
    summon(
       qw<
         +Plumbing::sequence
         +Source::iterate_files
         +Reader::read_by_line
         +Parser::parse_hashy
         +Renderer::render_with_template_perlish
         +Writer::write_to_files
         >
    );

    # define a tube made of a sequence of tubes, each of the relevant
    # type and doing its specific job.
    my $sequence = sequence(
       tubes => [
          iterate_files(files => [\"n=Flavio|q=how are you\nn=X|q=Y"]),
          read_by_line(),
          parse_hashy(chunks_separator => '|'),
          render_with_template_perlish(template => "Hi [% n %], [% q %]?\n"),
          write_to_files(filename => \*STDOUT),
       ],
    );

    # just "drain" whatever comes out of the tube, we're not really
    # interesting in collecting output records as they are already
    # written by write_to_file. This is necessary so that the actions are
    # actually "run", as of now $sequence is only a promise to do some
    # work.
    drain($sequence);

=head1 DESCRIPTION

This module allows you to define I<Tubes>, which are little more than
transformation subroutines over records.

=head1 FUNCTIONS

=over

=item B<< drain >>

   drain($tube, @tube_inputs);

drain whatever comes out of a tube. The tube is run with the provided
inputs, and if an iterator comes out of it, it is repeatedly run until
it provides no more output records.

=item B<< summon >>

   # Direct function import
   summon('Some::Package::subroutine');

   # DWIM, treat 'em as plugins under Data::Tubes::Plugin
   summon(
      {
         '+Source' => [ qw< iterate_array open_file > ],
      },
      [ qw< +Plumbing sequence logger > ],
      '+Reader::read_by_line',
   );

summon operations, most likely from plugins.  This is pretty much the
same as a regular C<import> done by C<use>, only supposed to be easier
to use in a script.

You can pass different things:

=over

=item I<array>

the first item in the array will be considered the package name, the
following ones sub names inside that package;

=item I<hash>

each key will be considered a package name, pointing to either a string
(considered a sub name) or an array (each item considered a sub name);

=item I<string>

this will be considered a fully qualified sub name, i.e. including the
package name at the beginning.

=back

In every case, if the package name starts with a C<+> plus sign, the
package name will be considered relative to C<Data::Tubes::Plugin>, so
the C<+> plus sign will be substitued with C<Data::Tubes::Plugin::>. For
example:

   +Plumbing becomes Data::Tubes::Plugin::Plumbing
   +Reader   becomes Data::Tubes::Plugin::Reader

and so on.

It's probable that the C<import> method will be overridden to make this
import easy directly upon C<use>-ing this module, instead of explicitly
calling C<summon>.

=back

=head1 BUGS AND LIMITATIONS

Report bugs either through RT or GitHub (patches welcome).

=head1 AUTHOR

Flavio Poletti <polettix@cpan.org>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2016 by Flavio Poletti <polettix@cpan.org>

This module is free software. You can redistribute it and/or modify it
under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
